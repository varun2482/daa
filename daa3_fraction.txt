def fractional_knapsack(value, weight, capacity):
    # Calculate value-to-weight ratio for each item
    ratio = [v/w for v, w in zip(value, weight)]
    
    # Create an index list sorted by the value-to-weight ratio in decreasing order
    index = list(range(len(value)))
    index.sort(key=lambda i: ratio[i], reverse=True)
    
    max_value = 0  # To store the maximum value of items in the knapsack
    fractions = [0] * len(value)  # To store fractions of items selected
    
    # Iterate over items according to the sorted index
    for i in index:
        if weight[i] <= capacity:  # If the item can be fully taken
            fractions[i] = 1
            max_value += value[i]
            capacity -= weight[i]
        else:  # If only part of the item can be taken
            fractions[i] = capacity / weight[i]
            max_value += value[i] * capacity / weight[i]
            break  # Knapsack is full, so break the loop

    return max_value, fractions

# Input handling
n = int(input('Enter number of items: '))

value = input('Enter the values of the {} item(s) in order: '.format(n)).split()
value = [int(v) for v in value]

weight = input('Enter the positive weights of the {} item(s) in order: '.format(n)).split()
weight = [int(w) for w in weight]

capacity = int(input('Enter maximum weight capacity: '))

# Call the fractional_knapsack function and output the results
max_value, fractions = fractional_knapsack(value, weight, capacity)
print('The maximum value of items that can be carried:', max_value)
print('The fractions in which the items should be taken:', fractions)
# Input for maximum weight (capacity)
capacity = int(input('Enter maximum weight: '))

# Function call to perform the fractional knapsack
max_value, fractions = fractional_knapsack(value, weight, capacity)

# Output the results
print('The maximum value of items that can be carried:', max_value)
print('The fractions in which the items should be taken:', fractions)
